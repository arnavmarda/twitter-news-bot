{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#twitter-news-bot","title":"twitter-news-bot","text":"<p>A python API allowing users to:</p> <ol> <li>Scrape news articles from Google News.</li> <li>Extract the articles from the news sources.</li> <li>Create and post tweets(or now Xs) using <code>tweepy</code>.</li> <li>Leverage PaLM to generate summaries from articles as tweets and to generate tweets.</li> <li>Pipeline and automate the scraping and tweeting procedure using a <code>cron</code> job.</li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<p>For complete documentation and examples, please refer to the documentation.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install twitter-news-bot\n</code></pre>"},{"location":"#requirements-before-using-the-api","title":"Requirements - before using the API","text":"<p>For more information on how to generate the following keys and tokens, please refer to the documentation.</p> <ol> <li> <p>To use the <code>tweepy</code> API to post tweets, you must have a Twitter developer account and create an app. You can create an app here. Don't worry, Twitter gives you 1 free app. Once you have created an app, you will need to generate the following keys and tokens:</p> <ul> <li>Consumer API key</li> <li>Consumer API secret key</li> <li>Access token</li> <li>Access token secret</li> </ul> </li> <li> <p>To use PaLM to generate tweets and completely automate the process, you will need to generate a PaLM API. To get this, you will need to sign up for the waitlist here. You can then generate the API key.</p> </li> </ol> <p>These keys must be stored in a <code>.env</code> file in the root directory of your project. The <code>.env</code> file should look like this:</p> <pre><code>API_KEY=\"your-key-here\"\nAPI_SECRET_KEY=\"your-key-here\"\nACCESS_TOKEN=\"your-key-here\"\nACCESS_TOKEN_SECRET=\"your-key-here\"\nGOOGLE_API_KEY=\"your-key-here\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The API is very simple to use. Here is a quick example:</p> <pre><code>from twitter_news_bot.tweeter import Tweeter\nfrom twitter_news_bot.newsfinder import NewsFinder\nfrom twitter_news_bot.twitternewsbot import TwitterNewsBot\n\n# Create a NewsFinder and Tweeter Object\nnf = NewsFinder()\nt = Tweeter()\n\n# Create a TwitterNewsBot object\ntnb = TwitterNewsBot(nf, t, topic=\"AI\")\n\n# Run the TwitterNewsBOt to scrape articles, extract them, summarize them and post them as tweets\ntnb.run()\n</code></pre>"},{"location":"#future-updates","title":"Future Updates","text":"<ul> <li>[ ] Add support for other summarization models such as OpenAI.</li> <li>[ ] Add region based searching for news articles on Google News.</li> </ul>"},{"location":"github-actions/","title":"Using Github-Actions","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"newsfinder/","title":"News Finder Class","text":""},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder","title":"<code>NewsFinder</code>","text":"<p>API Object to scrape news articles from Google News and scrape the article text from the news website.  Allows filtering of Google News results.</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>class NewsFinder():\n\n\"\"\"\n    API Object to scrape news articles from Google News and scrape the article text from the news website. \n    Allows filtering of Google News results.\n    \"\"\"\n\n    #####################################\n    # Initialization\n    #####################################\n\n    def __init__(self, blocked_sources: list|None = None):\n\"\"\"Initialize the NewsFinder class\n\n        Parameters\n        ----------\n        blocked_sources : list, optional\n            A list of sources to block, by default includes Daily Mail and News18            \n        \"\"\"\n\n\n\n        if blocked_sources is None:\n            self.blocked_sources = [\"Daily Mail\", \"News18\"]\n        else:\n\n            # Check if blocked_sources is valid\n            if not isinstance(blocked_sources, list):\n                raise TypeError(\"blocked_sources must be a list\")\n\n            # Check if all elements in blocked_sources are strings\n            if not all(isinstance(source, str) for source in blocked_sources):\n                raise TypeError(\"blocked_sources must be a list of strings\")\n\n            self.blocked_sources = blocked_sources + [\"Daily Mail\", \"News18\"]\n\n    #####################################\n    # Private Methods\n    #####################################\n\n    def __scrape_articles(self, url: str, number_of_articles: int = 5) -&gt; list | None:\n\"\"\"Private: Scrape the news articles from Google News for a given topic\n\n        Parameters\n        ----------\n        url : str\n            The google news url to scrape\n        number_of_articles : int, optional \n            The number of articles to scrape, by default 5\n\n        Returns\n        -------\n        all_articles : list\n            A list of dictionaries containing the title, source, time and link of each article\n        \"\"\"\n\n        # Initialize an HTML Session\n        session = HTMLSession()\n\n        # Get the page\n        r = session.get(url=url)\n\n        # Get all the articles\n        try:\n            articles = r.html.find('article')\n        except:\n            return None\n\n        all_articles = []\n\n        # Iterate over each article\n        for article in articles:\n\n            # Break if we have enough articles\n            if len(all_articles) == number_of_articles:\n                break\n\n            # Get the title\n            title = article.find('h3', first=True).text\n\n            # Get the source\n            source = article.find('img', first=True).attrs.get('alt')\n\n            # Disallow certain sources\n            if source in self.blocked_sources:\n                continue\n\n            # Get the link\n            link = article.find('a', first=True).absolute_links.pop()\n\n            # Print the details\n            newsarticle = {\n                'title': title,\n                'source': source,\n                'link': link\n            }\n            all_articles.append(newsarticle)\n\n        return all_articles\n\n    def __scrape_news_article(self, url: str) -&gt; dict | None:\n\"\"\"Private: Scrape the news article from the given url\n\n        Parameters\n        ----------\n        url : str\n            The google news url of the news article\n\n        Returns\n        -------\n        article : dict\n            A dictionary containing the title and article body of the news article\n        \"\"\"\n\n\n        # Final url\n        try:\n            url = requests.get(url, timeout=5).url\n        except Exception as error:\n            warnings.warn(f\"Error processing url: {url}. Continuing without it...\")\n            return None\n\n        # Initialize HTML Session\n        session = HTMLSession()\n\n        # Get the page\n        r = session.get(url=url)\n\n        # Get the title\n        try:\n            title  = r.html.find('h1', first=True).text\n        except:\n            title = \"\"\n\n        # Get all article fragments (each fragment is a paragraph)\n        try:\n            article_fragments = r.html.find('p')\n        except:\n            warnings.warn(f\"Article with url: {url} cannot be scraped. Continuing without it...\")\n            return None\n\n\n        # Join all the paragraphs to form the article\n        body = '\\n'.join([fragment.text for fragment in article_fragments])\n\n        return {'title': title, 'article': body}\n\n    def __build_list_of_articles(self, articles_list: list) -&gt; list:\n\"\"\"Private: Build a list of articles from the given list of dictionaries\n\n        Parameters\n        ----------\n        articles_list : list(dict)\n            A list of dictionaries containing the title, source, date and link of the articles\n\n        Returns\n        -------\n        articles_full_text : list\n            A list of dictionaries containing the title and article body of the news articles\n        \"\"\"\n\n        # Iterate through articles, and scrape each one\n        for article in articles_list:\n            article_text = self.__build_article_from_dict(article)\n            article.update(article_text)\n        return articles_list\n\n    def __build_article_from_dict(self, article_dict: dict) -&gt; dict | None:\n\"\"\"Private: Build the article from the given dictionary\n\n        Parameters\n        ----------\n        article_dict : dict\n            A dictionary containing the title, source, date and link of the article\n\n        Returns\n        -------\n        article : dict\n            A dictionary containing the title and article body of the news article\n        \"\"\"\n\n        return self.__scrape_news_article(article_dict['link'])\n\n    def __build_url(self, topic_url: str, source_url: str, period_url: str) -&gt; str:\n\"\"\"Private: Build the url for the given topic, source and period\n\n        Parameters\n        ----------\n        topic_url : str\n            The topic to search for\n        source_url : str\n            The url fragment of the source to search for\n        period_url : str\n            The url fragment of the period to search for\n\n        Returns \n        -------\n        url : str\n            The url to scrape\n        \"\"\"\n\n        return f'https://news.google.com/search?q={topic_url}{source_url}{period_url}&amp;hl=en-IN&amp;gl=IN&amp;ceid=IN:en'\n\n\n    ###############################\n    # Public Methods - API Methods\n    ###############################\n\n    def add_blocked_source(self, sources: list) -&gt; int:\n\"\"\"Add a list of sources to block\n\n        Parameters\n        ----------\n        sources : list\n            A list of sources to block\n\n        Returns\n        -------\n        int\n            The number of blocked sources\n\n        Raises\n        ------\n        TypeError\n            If sources is not a list\n        \"\"\"\n\n        # Check if the sources is valid\n        if not isinstance(sources, list):\n            raise TypeError(\"Sources must be a list\")\n\n        # Check if the source is already blocked\n        for source in sources:\n            if source in self.blocked_sources:\n                sources.remove(source)\n\n        self.blocked_sources = self.blocked_sources + sources\n        return len(self.blocked_sources)\n\n    def remove_blocked_source(self, sources: list) -&gt; int:\n\"\"\"Remove a list of sources to block\n\n        Parameters\n        ----------\n        sources : list\n            A list of sources to block\n\n        Returns\n        -------\n        int\n            The number of blocked sources\n\n        Raises\n        ------\n        TypeError\n            If sources is not a list\n        \"\"\"\n\n        # Check if the sources is valid\n        if not isinstance(sources, list):\n            raise TypeError(\"Sources must be a list\")\n\n        for source in sources:\n            self.blocked_sources.remove(source)\n        return len(self.blocked_sources)\n\n    def get_blocked_sources(self) -&gt; list:\n\"\"\"Get the list of blocked sources\n\n        Returns\n        -------\n        list\n            The list of blocked sources\n        \"\"\"\n\n        return self.blocked_sources\n\n    @property\n    def blocked_sources(self) -&gt; list:\n\"\"\"Get the list of blocked sources\n\n        Returns\n        -------\n        list\n            The list of blocked sources\n        \"\"\"\n\n        return self.__blocked_sources\n\n    @blocked_sources.setter\n    def blocked_sources(self, sources: list) -&gt; None:\n\"\"\"Set the list of blocked sources\n\n        Parameters\n        ----------\n        sources : list\n            A list of sources to block\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If sources is not a list\n        \"\"\"\n\n        # Check if the sources is valid\n        if not isinstance(sources, list):\n            raise TypeError(\"sources must be a list\")\n\n        self.__blocked_sources = sources\n\n    def update_blocked_sources(self, sources: list) -&gt; int:\n\"\"\"Update the list of blocked sources by completely replacing existing blocked sources\n\n        Parameters\n        ----------\n        sources : list\n            A list of sources to block\n\n        Returns\n        -------\n        int\n            The number of blocked sources\n\n        Raises\n        ------\n        TypeError\n            If sources is not a list\n        \"\"\"\n        # Check if the sources is valid\n        if not isinstance(sources, list):\n            raise TypeError(\"Sources must be a list\")\n\n        self.blocked_sources = sources\n        return len(self.blocked_sources)\n\n    def get_news_articles(self, topic: str|None = None, number_of_articles: int|None = None, source: str|None = None, period: str = \"Any time\", article_text: bool = False) -&gt; list:\n\"\"\"Get the news articles for a given topic or for a given source filtered by date\n\n        Parameters\n        ----------\n        topic : str, optional\n            The topic to search for, by default None\n        number_of_articles : int, optional\n            The number of articles to scrape, by default None which gives all the possible articles\n        source : str, optional\n            The domain for the website of the source to search for, by default None. For example, \"dailymail.co.uk\" or \"bbc.com\"\n        period : list, optional\n            The period to search for, by default \"Any time\". Period must be one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"]\n        article_text : bool, optional\n            Whether to scrape the article text or not, by default False\n\n        Returns\n        -------\n        list\n            A list of dictionaries containing the title, source, link and article body of the news articles (only if article_text is True)\n\n        Raises\n        ------\n        ValueError\n            If the period is not one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"].\n        ValueError\n            If the number_of_articles is not a positive integer\n        TypeError\n            If the topic is not a string\n        TypeError\n            If the source is not a string\n        ValueError\n            If the source is not a valid domain name\n        TypeError\n            If the article_text is not a boolean\n        ValueError\n            If the topic and source are both None\n        \"\"\"\n\n        # Check if the period is valid\n        if period not in [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"]:\n            raise ValueError(\"period must be one of ['Any time', 'Past hour', 'Past 24 hours', 'Past week', 'Past year']\")\n\n        # Check if the number of articles is valid\n        if number_of_articles is not None and number_of_articles &lt;= 0:\n            raise ValueError(\"number_of_articles must be a positive integer\")\n\n        # Check if the topic is valid\n        if topic is not None and not isinstance(topic, str):\n            raise TypeError(\"topic must be a string\")\n\n        # Check if the source is valid\n        if source is not None and not isinstance(source, str):\n            raise TypeError(\"source must be a string\")\n\n        if source is not None and not domain(source):\n            raise ValueError(\"source must be a valid domain name\")\n\n        # Check if the article_text is valid\n        if not isinstance(article_text, bool):\n            raise TypeError(\"article_text must be a boolean\")\n\n        # Check if the topic and source are both None\n        if topic is None and source is None:\n            raise ValueError(\"Either or both topic and source must be provided\")\n\n        ################### Build url ######################\n\n        # If topic is provided\n        if topic is not None:\n            topic_url = topic + \" \"\n        else:\n            topic_url = \"\"\n\n        # If source is provided\n        if source is not None:\n            source_url = \" site:\" + source\n        else:\n            source_url = \"\"\n\n        # If period is provided\n\n        period_mappings = {\"Any time\": \"\",\n                           \"Past hour\": \" when:1h\",\n                           \"Past 24 hours\": \" when:1d\",\n                           \"Past week\": \" when:7d\",\n                           \"Past year\": \" when:1y\"}\n\n        period_url = period_mappings[period]\n\n        url = self.__build_url(topic_url, source_url, period_url)\n\n\n        ################### Scrape ######################\n\n        articles = self.__scrape_articles(url, number_of_articles)\n\n        # Check and report if no articles found\n        if articles is None:\n            sys.stdout.write(\"No articles found. Try different parameters\")\n            return []\n\n\n        ################### Build Articles ######################\n        if article_text:\n            articles = self.__build_list_of_articles(articles)\n\n        return articles\n</code></pre>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.blocked_sources","title":"<code>blocked_sources: list</code>  <code>property</code> <code>writable</code>","text":"<p>Get the list of blocked sources</p> RETURNS DESCRIPTION <code>list</code> <p>The list of blocked sources</p>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.add_blocked_source","title":"<code>add_blocked_source(sources)</code>","text":"<p>Add a list of sources to block</p> PARAMETER  DESCRIPTION <code>sources</code> <p>A list of sources to block</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of blocked sources</p> RAISES DESCRIPTION <code>TypeError</code> <p>If sources is not a list</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>def add_blocked_source(self, sources: list) -&gt; int:\n\"\"\"Add a list of sources to block\n\n    Parameters\n    ----------\n    sources : list\n        A list of sources to block\n\n    Returns\n    -------\n    int\n        The number of blocked sources\n\n    Raises\n    ------\n    TypeError\n        If sources is not a list\n    \"\"\"\n\n    # Check if the sources is valid\n    if not isinstance(sources, list):\n        raise TypeError(\"Sources must be a list\")\n\n    # Check if the source is already blocked\n    for source in sources:\n        if source in self.blocked_sources:\n            sources.remove(source)\n\n    self.blocked_sources = self.blocked_sources + sources\n    return len(self.blocked_sources)\n</code></pre>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.remove_blocked_source","title":"<code>remove_blocked_source(sources)</code>","text":"<p>Remove a list of sources to block</p> PARAMETER  DESCRIPTION <code>sources</code> <p>A list of sources to block</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of blocked sources</p> RAISES DESCRIPTION <code>TypeError</code> <p>If sources is not a list</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>def remove_blocked_source(self, sources: list) -&gt; int:\n\"\"\"Remove a list of sources to block\n\n    Parameters\n    ----------\n    sources : list\n        A list of sources to block\n\n    Returns\n    -------\n    int\n        The number of blocked sources\n\n    Raises\n    ------\n    TypeError\n        If sources is not a list\n    \"\"\"\n\n    # Check if the sources is valid\n    if not isinstance(sources, list):\n        raise TypeError(\"Sources must be a list\")\n\n    for source in sources:\n        self.blocked_sources.remove(source)\n    return len(self.blocked_sources)\n</code></pre>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.get_blocked_sources","title":"<code>get_blocked_sources()</code>","text":"<p>Get the list of blocked sources</p> RETURNS DESCRIPTION <code>list</code> <p>The list of blocked sources</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>def get_blocked_sources(self) -&gt; list:\n\"\"\"Get the list of blocked sources\n\n    Returns\n    -------\n    list\n        The list of blocked sources\n    \"\"\"\n\n    return self.blocked_sources\n</code></pre>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.update_blocked_sources","title":"<code>update_blocked_sources(sources)</code>","text":"<p>Update the list of blocked sources by completely replacing existing blocked sources</p> PARAMETER  DESCRIPTION <code>sources</code> <p>A list of sources to block</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of blocked sources</p> RAISES DESCRIPTION <code>TypeError</code> <p>If sources is not a list</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>def update_blocked_sources(self, sources: list) -&gt; int:\n\"\"\"Update the list of blocked sources by completely replacing existing blocked sources\n\n    Parameters\n    ----------\n    sources : list\n        A list of sources to block\n\n    Returns\n    -------\n    int\n        The number of blocked sources\n\n    Raises\n    ------\n    TypeError\n        If sources is not a list\n    \"\"\"\n    # Check if the sources is valid\n    if not isinstance(sources, list):\n        raise TypeError(\"Sources must be a list\")\n\n    self.blocked_sources = sources\n    return len(self.blocked_sources)\n</code></pre>"},{"location":"newsfinder/#twitternewsbot.newsfinder.NewsFinder.get_news_articles","title":"<code>get_news_articles(topic=None, number_of_articles=None, source=None, period='Any time', article_text=False)</code>","text":"<p>Get the news articles for a given topic or for a given source filtered by date</p> PARAMETER  DESCRIPTION <code>topic</code> <p>The topic to search for, by default None</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>number_of_articles</code> <p>The number of articles to scrape, by default None which gives all the possible articles</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>source</code> <p>The domain for the website of the source to search for, by default None. For example, \"dailymail.co.uk\" or \"bbc.com\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>period</code> <p>The period to search for, by default \"Any time\". Period must be one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"]</p> <p> TYPE: <code>list</code> DEFAULT: <code>'Any time'</code> </p> <code>article_text</code> <p>Whether to scrape the article text or not, by default False</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list</code> <p>A list of dictionaries containing the title, source, link and article body of the news articles (only if article_text is True)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the period is not one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"].</p> <code>ValueError</code> <p>If the number_of_articles is not a positive integer</p> <code>TypeError</code> <p>If the topic is not a string</p> <code>TypeError</code> <p>If the source is not a string</p> <code>ValueError</code> <p>If the source is not a valid domain name</p> <code>TypeError</code> <p>If the article_text is not a boolean</p> <code>ValueError</code> <p>If the topic and source are both None</p> Source code in <code>twitternewsbot/newsfinder.py</code> <pre><code>def get_news_articles(self, topic: str|None = None, number_of_articles: int|None = None, source: str|None = None, period: str = \"Any time\", article_text: bool = False) -&gt; list:\n\"\"\"Get the news articles for a given topic or for a given source filtered by date\n\n    Parameters\n    ----------\n    topic : str, optional\n        The topic to search for, by default None\n    number_of_articles : int, optional\n        The number of articles to scrape, by default None which gives all the possible articles\n    source : str, optional\n        The domain for the website of the source to search for, by default None. For example, \"dailymail.co.uk\" or \"bbc.com\"\n    period : list, optional\n        The period to search for, by default \"Any time\". Period must be one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"]\n    article_text : bool, optional\n        Whether to scrape the article text or not, by default False\n\n    Returns\n    -------\n    list\n        A list of dictionaries containing the title, source, link and article body of the news articles (only if article_text is True)\n\n    Raises\n    ------\n    ValueError\n        If the period is not one of [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"].\n    ValueError\n        If the number_of_articles is not a positive integer\n    TypeError\n        If the topic is not a string\n    TypeError\n        If the source is not a string\n    ValueError\n        If the source is not a valid domain name\n    TypeError\n        If the article_text is not a boolean\n    ValueError\n        If the topic and source are both None\n    \"\"\"\n\n    # Check if the period is valid\n    if period not in [\"Any time\", \"Past hour\", \"Past 24 hours\", \"Past week\", \"Past year\"]:\n        raise ValueError(\"period must be one of ['Any time', 'Past hour', 'Past 24 hours', 'Past week', 'Past year']\")\n\n    # Check if the number of articles is valid\n    if number_of_articles is not None and number_of_articles &lt;= 0:\n        raise ValueError(\"number_of_articles must be a positive integer\")\n\n    # Check if the topic is valid\n    if topic is not None and not isinstance(topic, str):\n        raise TypeError(\"topic must be a string\")\n\n    # Check if the source is valid\n    if source is not None and not isinstance(source, str):\n        raise TypeError(\"source must be a string\")\n\n    if source is not None and not domain(source):\n        raise ValueError(\"source must be a valid domain name\")\n\n    # Check if the article_text is valid\n    if not isinstance(article_text, bool):\n        raise TypeError(\"article_text must be a boolean\")\n\n    # Check if the topic and source are both None\n    if topic is None and source is None:\n        raise ValueError(\"Either or both topic and source must be provided\")\n\n    ################### Build url ######################\n\n    # If topic is provided\n    if topic is not None:\n        topic_url = topic + \" \"\n    else:\n        topic_url = \"\"\n\n    # If source is provided\n    if source is not None:\n        source_url = \" site:\" + source\n    else:\n        source_url = \"\"\n\n    # If period is provided\n\n    period_mappings = {\"Any time\": \"\",\n                       \"Past hour\": \" when:1h\",\n                       \"Past 24 hours\": \" when:1d\",\n                       \"Past week\": \" when:7d\",\n                       \"Past year\": \" when:1y\"}\n\n    period_url = period_mappings[period]\n\n    url = self.__build_url(topic_url, source_url, period_url)\n\n\n    ################### Scrape ######################\n\n    articles = self.__scrape_articles(url, number_of_articles)\n\n    # Check and report if no articles found\n    if articles is None:\n        sys.stdout.write(\"No articles found. Try different parameters\")\n        return []\n\n\n    ################### Build Articles ######################\n    if article_text:\n        articles = self.__build_list_of_articles(articles)\n\n    return articles\n</code></pre>"},{"location":"tweeter/","title":"Tweeter Class","text":""},{"location":"tweeter/#twitternewsbot.tweeter.Tweeter","title":"<code>Tweeter</code>","text":"<p>API Object allowing users to tweet articles, summaries and other text to Twitter.  It leverages PaLM to summarize articles and then tweets them in chunks of 280 characters. Requires having the Twitter API API_KEY, API_SECRET_KEY, ACCESS_TOKEN and ACCESS_TOKEN_SECRET set as environment variables.</p> Source code in <code>twitternewsbot/tweeter.py</code> <pre><code>class Tweeter():\n\n\"\"\"\n    API Object allowing users to tweet articles, summaries and other text to Twitter. \n    It leverages PaLM to summarize articles and then tweets them in chunks of 280 characters.\n    Requires having the Twitter API API_KEY, API_SECRET_KEY, ACCESS_TOKEN and ACCESS_TOKEN_SECRET set as environment variables.\n    \"\"\"\n\n  #####################################\n  # Initialization\n  #####################################\n\n    def __init__(self):\n\"\"\"Initialize the class with tokens and tweepy client\"\"\"\n\n        # Load environment variables\n        load_dotenv()\n        try:\n            self.__API_KEY = os.getenv(\"API_KEY\")\n        except:\n            raise Exception(\"API_KEY not found in environment variables\")\n\n        try:\n            self.__API_SECRET_KEY = os.getenv(\"API_SECRET_KEY\")\n        except:\n            raise Exception(\"API_SECRET_KEY not found in environment variables\")\n\n        try:\n            self.__ACCESS_TOKEN = os.getenv(\"ACCESS_TOKEN\")\n        except:\n            raise Exception(\"ACCESS_TOKEN not found in environment variables\")\n\n        try:\n            self.__ACCESS_TOKEN_SECRET = os.getenv(\"ACCESS_TOKEN_SECRET\")\n        except:\n            raise Exception(\"ACCESS_TOKEN_SECRET not found in environment variables\")\n\n        try:\n            self.__client = Client(consumer_key=self.__API_KEY, \n                                   consumer_secret=self.__API_SECRET_KEY, \n                                   access_token=self.__ACCESS_TOKEN, \n                                   access_token_secret=self.__ACCESS_TOKEN_SECRET)\n        except:\n            raise Exception(\"Authentication Failed. Invalid Twitter API Credentials\")\n\n\n\n  #####################################\n  # Private Methods\n  #####################################\n\n    def __tweet(self, text: str) -&gt; dict:\n\"\"\"Private: Tweet the given text\n\n        Parameters\n        ----------\n        text : str\n            The text to be tweeted\n\n        Returns\n        -------\n        dict\n            A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet\n        \"\"\"\n\n        # Create chunks\n        total_char_count = len(text)\n        text = list(self.__create_chunks(text))\n\n\n        no_of_chunks = len(text)\n\n        # Seperate parent tweet from children tweets\n        parent_tweet_text = text[0]\n        leaf_tweets = text[1:]\n\n        # Post parent tweet\n        parent_tweet_id = self.__parent_tweet(text=parent_tweet_text)\n\n        # Post children tweets\n        for leaf_tweet in leaf_tweets:\n            self.__child_tweet(text=leaf_tweet, parent_tweet_id=parent_tweet_id)\n\n        return {\"Total Character Count\": total_char_count, \"No. of Tweets\": no_of_chunks, \"Parent Tweet ID\": parent_tweet_id}\n\n    def __parent_tweet(self, text: str) -&gt; str | None:\n\"\"\"Post the parent tweet and return the id of the tweet\n\n        Parameters\n        ----------\n        text : str\n            The text to be tweeted\n\n        Returns\n        -------\n        parent_tweet_id : str\n            The id of the tweet\n        \"\"\"\n        try:\n            parent_tweet_id = self.__client.create_tweet(text=text).data['id']\n            return parent_tweet_id\n        except Exception as error:\n            raise Exception(f\"Tweet not posted succesfully: {error}\")\n\n    def __child_tweet(self, text: str, parent_tweet_id: str) -&gt; None:\n\"\"\"Post the child tweet as a reply to the parent tweet\n\n        Parameters\n        ----------\n        text : str\n            The text to be tweeted as a reply to the parent tweet\n        parent_tweet_id : str\n            The id of the parent tweet\n\n        Returns\n        -------\n        None\n        \"\"\"\n        try:\n            self.__client.create_tweet(text=text, in_reply_to_tweet_id=parent_tweet_id)\n        except Exception as error:\n            raise Exception(f\"Tweet not posted succesfully: {error}\")\n\n\n    def __create_chunks(self, text: str) -&gt; list:\n\"\"\"Create chunks of 280 characters each from the given text while leveraging the yield keyword\n\n        Parameters\n        ----------\n        text : str\n            The text to be chunked\n\n        Returns\n        -------\n        chunks : list(str)\n            A list of 280 char chunks of the given text\n        \"\"\"\n        for start in range(0, len(text), 280):\n            yield text[start:start + 280]\n\n\n    def __summarize_article(self, article: dict, prompt: str|None) -&gt; str | None:\n\"\"\"Summarize the given article using Google PaLM API\n\n        Parameters\n        ----------\n        article : dict\n            A dictionary containing the title and article body of the news article\n        prompt : str, optional\n            The prompt to be used for the summarization, by default None\n\n        Returns\n        -------\n        summary : str\n            The summary of the article created using GOOGLE PaLM\n        \"\"\"\n\n        # Get the API key\n        try:\n            GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')\n        except:\n            raise Exception(\"GOOGLE_API_KEY not found in environment variables\")\n\n        # Initialize PaLM\n        try:\n            palm.configure(api_key=GOOGLE_API_KEY)\n        except:\n            raise Exception(\"Authentication Failed. Invalid Google API Credentials\")\n\n        # Default Settings\n        defaults = {\n                        'model': 'models/text-bison-001',\n                        'temperature': 0.1,\n                        'candidate_count': 1,\n                        'top_k': 40,\n                        'top_p': 0.95,\n                        'max_output_tokens': 1024,\n                        'stop_sequences': [],\n                        'safety_settings': [{\"category\":\"HARM_CATEGORY_DEROGATORY\",\"threshold\":1},{\"category\":\"HARM_CATEGORY_TOXICITY\",\"threshold\":1},{\"category\":\"HARM_CATEGORY_VIOLENCE\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_SEXUAL\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_MEDICAL\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_DANGEROUS\",\"threshold\":2}],\n                    }\n\n        # Create a prompt\n        prompt = f\"\"\"\n        Summarize the following article and condense it into 2 bullet points. Add the title of the article at the top. Do not leave an empty line after the article. Only use information from the article provided below. Structure your response as follows:\n\n        Format for Summary:\n        Title\n        - Bullet point 1\n        - Bullet point 2\n\n        Title - {article['title']}\n        Article - {article['article']}\n\n        Summary:\n        \"\"\" if prompt is None else f\"\"\"{prompt}\"\"\"\n\n        # Generate the tweet\n        try:\n            tweet = palm.generate_text(**defaults, prompt=prompt)\n            return tweet.result\n        except:\n            raise Exception(\"Failed to generate tweet using PaLM\")\n\n\n    def __clean_tweet(self, tweet_text: str) -&gt; str:\n\"\"\"Clean the tweet by removing unwanted characters as PaLM adds '*' to the tweet occasionally\n\n        Parameters\n        ----------\n        tweet_text : str\n            The text of the tweet to be cleaned\n\n        Returns\n        -------\n        tweet_text : str\n            The cleaned tweet text\n        \"\"\"\n\n        # Remove * from tweet\n        tweet_text = tweet_text.replace('*', '')\n        return tweet_text\n\n    def __handle_articles_list(self, articles_list: list, title: str|None, prompt: str|None) -&gt; str | None:\n\"\"\"Handle the list of articles by summarizing them and returning a generated tweet\n\n        Parameters\n        ----------\n        articles_list : list(dict)\n            A list of dictionaries containing the title, source, date and link of the articles\n        title : str, optional\n            The title of the tweet\n        prompt : str, optional\n            The prompt to be used for the summarization, by default None\n\n        Returns\n        -------\n        articles_generated_summary : str\n            The generated tweet from the articles\n        \"\"\"\n\n        # Add title of tweet to the beginning of the tweet\n        articles_generated_summary = f\"{title}:\\n\\n\"\n\n        # Add the summary for each article to the tweet\n        for article in articles_list:\n            # Call API to get summary\n            summary = self.__summarize_article(article, prompt)\n\n            # If summary is None, continue by skipping article\n            if summary is None:\n                continue\n\n            # Clean the summary\n            articles_generated_summary += self.__clean_tweet(summary)\n\n            # Add a new line, formatting\n            articles_generated_summary += \"\\n\\n\"\n\n        # Return the generated summary\n        return articles_generated_summary\n\n    def __generate_with_palm(self, prompt: str|None) -&gt; str | None:\n\"\"\"Generate a tweet using PaLM\n\n        Parameters\n        ----------\n        prompt : str, optional\n            The prompt to be used for generation, by default None\n        to_rewrite : str, optional\n            The text to be rewritten, by default None\n        Returns\n        -------\n        generated_summary : str\n            The generated tweet\n        \"\"\"\n\n        # Get the API key\n        try:\n            GOOGLE_API_KEY = os.environ['GOOGLE_API_KEY']\n        except:\n            raise Exception(\"GOOGLE_API_KEY not found in environment variables\")\n\n        # Initialize PaLM\n        try:\n            palm.configure(api_key=GOOGLE_API_KEY)\n        except:\n            raise Exception(\"Authentication Failed. Invalid Google API Credentials\")\n\n        # Default Settings\n        defaults = {\n                        'model': 'models/text-bison-001',\n                        'temperature': 0.1,\n                        'candidate_count': 1,\n                        'top_k': 40,\n                        'top_p': 0.95,\n                        'max_output_tokens': 1024,\n                        'stop_sequences': [],\n                        'safety_settings': [{\"category\":\"HARM_CATEGORY_DEROGATORY\",\"threshold\":1},{\"category\":\"HARM_CATEGORY_TOXICITY\",\"threshold\":1},{\"category\":\"HARM_CATEGORY_VIOLENCE\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_SEXUAL\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_MEDICAL\",\"threshold\":2},{\"category\":\"HARM_CATEGORY_DANGEROUS\",\"threshold\":2}],\n                    }\n\n        # Generate the tweet\n        try:\n            tweet = palm.generate_text(**defaults, prompt=prompt)\n            return tweet.result\n        except:\n            raise Exception(\"Failed to generate tweet using PaLM\")\n\n\n\n\n  #####################################\n  # Public Methods - API Methods\n  #####################################\n\n    def get_client(self) -&gt; Client:\n\"\"\"Get the tweepy client object\n\n        Returns\n        -------\n        client : Client\n            The tweepy client object\n        \"\"\"\n        return self.__client\n\n    def tweet(self, title: str|None = None, tweet: str|None = None, articles_list: list|None = None, use_palm: bool = False, prompt: str|None = None) -&gt; dict:\n\"\"\"Tweet the given articles list\n\n        Parameters\n        ----------\n        title : str, optional\n            The title of the tweet\n        tweet : str, optional\n            The tweet to be posted\n        articles_list : list, optional\n            A list of dictionaries containing the title, source, link and text of the articles.\n            Obtained from the NewsFinder.get_news_articles() method\n        use_palm : bool, optional\n            A boolean value indicating whether to use PaLM to generate tweet with prompt\n        prompt : str, optional\n            The prompt to be used for the summarization with PaLM\n\n        Returns\n        -------\n        tweet : dict\n            A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet\n\n        Raises\n        ------\n        TypeError\n            If title is not a string\n        TypeError\n            If tweet is not a string\n        TypeError\n            If articles_list is not a list of dictionaries\n        TypeError\n            If use_palm is not a boolean\n        ValueError\n            If use_palm is True and tweet or articles_list is not None\n        ValueError\n            If use_palm is True and prompt is None\n        ValueError\n            If tweet and articles_list are both not None\n        TypeError\n            If prompt is not a string\n        \"\"\"\n\n        # Check if title is valid\n        if title is not None and not isinstance(title, str):\n            raise TypeError(\"title must be a string\")\n\n        # Check if tweet is valid\n        if tweet is not None and not isinstance(tweet, str):\n            raise TypeError(\"tweet must be a string\")\n\n        # Check if articles_list is valid\n        if articles_list is not None and (not isinstance(articles_list, list) or not all(isinstance(article, dict) for article in articles_list)):\n            raise TypeError(\"articles_list must be a list of dicts\")\n\n        # Check if use_palm is valid\n        if use_palm is not None and not isinstance(use_palm, bool):\n            raise TypeError(\"use_palm must be a boolean\")\n\n        # Check if use_palm is True, then tweet and articles_list must be None\n        if use_palm is True and (tweet is not None or articles_list is not None):\n            raise ValueError(\"tweet and articles_list must be None if use_palm is True\")\n\n        # Check if prompt is not provided and use_palm is True\n        if prompt is None and use_palm is True:\n            raise ValueError(\"prompt must be provided if use_palm is True\")\n\n        # Check if tweet and articles_list are both provided\n        if tweet is not None and articles_list is not None:\n            raise ValueError(\"Both tweet and articles_list cannot be provided\")\n\n        # Check if prompt is valid\n        if prompt is not None and not isinstance(prompt, str):\n            raise TypeError(\"prompt must be a string\")\n\n        if articles_list is not None:\n            # Handle the articles list\n            tweet = self.__handle_articles_list(articles_list, title, prompt)\n        elif use_palm:\n            # Generate a tweet using PaLM\n            tweet = self.__generate_with_palm(prompt)\n            if title is not None:\n                tweet = f\"{title}:\\n\\n{tweet}\"\n\n        return self.__tweet(tweet)\n</code></pre>"},{"location":"tweeter/#twitternewsbot.tweeter.Tweeter.get_client","title":"<code>get_client()</code>","text":"<p>Get the tweepy client object</p> RETURNS DESCRIPTION <code>client</code> <p>The tweepy client object</p> <p> TYPE: <code>Client</code> </p> Source code in <code>twitternewsbot/tweeter.py</code> <pre><code>def get_client(self) -&gt; Client:\n\"\"\"Get the tweepy client object\n\n    Returns\n    -------\n    client : Client\n        The tweepy client object\n    \"\"\"\n    return self.__client\n</code></pre>"},{"location":"tweeter/#twitternewsbot.tweeter.Tweeter.tweet","title":"<code>tweet(title=None, tweet=None, articles_list=None, use_palm=False, prompt=None)</code>","text":"<p>Tweet the given articles list</p> PARAMETER  DESCRIPTION <code>title</code> <p>The title of the tweet</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>tweet</code> <p>The tweet to be posted</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>articles_list</code> <p>A list of dictionaries containing the title, source, link and text of the articles. Obtained from the NewsFinder.get_news_articles() method</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>use_palm</code> <p>A boolean value indicating whether to use PaLM to generate tweet with prompt</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>prompt</code> <p>The prompt to be used for the summarization with PaLM</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tweet</code> <p>A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet</p> <p> TYPE: <code>dict</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If title is not a string</p> <code>TypeError</code> <p>If tweet is not a string</p> <code>TypeError</code> <p>If articles_list is not a list of dictionaries</p> <code>TypeError</code> <p>If use_palm is not a boolean</p> <code>ValueError</code> <p>If use_palm is True and tweet or articles_list is not None</p> <code>ValueError</code> <p>If use_palm is True and prompt is None</p> <code>ValueError</code> <p>If tweet and articles_list are both not None</p> <code>TypeError</code> <p>If prompt is not a string</p> Source code in <code>twitternewsbot/tweeter.py</code> <pre><code>def tweet(self, title: str|None = None, tweet: str|None = None, articles_list: list|None = None, use_palm: bool = False, prompt: str|None = None) -&gt; dict:\n\"\"\"Tweet the given articles list\n\n    Parameters\n    ----------\n    title : str, optional\n        The title of the tweet\n    tweet : str, optional\n        The tweet to be posted\n    articles_list : list, optional\n        A list of dictionaries containing the title, source, link and text of the articles.\n        Obtained from the NewsFinder.get_news_articles() method\n    use_palm : bool, optional\n        A boolean value indicating whether to use PaLM to generate tweet with prompt\n    prompt : str, optional\n        The prompt to be used for the summarization with PaLM\n\n    Returns\n    -------\n    tweet : dict\n        A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet\n\n    Raises\n    ------\n    TypeError\n        If title is not a string\n    TypeError\n        If tweet is not a string\n    TypeError\n        If articles_list is not a list of dictionaries\n    TypeError\n        If use_palm is not a boolean\n    ValueError\n        If use_palm is True and tweet or articles_list is not None\n    ValueError\n        If use_palm is True and prompt is None\n    ValueError\n        If tweet and articles_list are both not None\n    TypeError\n        If prompt is not a string\n    \"\"\"\n\n    # Check if title is valid\n    if title is not None and not isinstance(title, str):\n        raise TypeError(\"title must be a string\")\n\n    # Check if tweet is valid\n    if tweet is not None and not isinstance(tweet, str):\n        raise TypeError(\"tweet must be a string\")\n\n    # Check if articles_list is valid\n    if articles_list is not None and (not isinstance(articles_list, list) or not all(isinstance(article, dict) for article in articles_list)):\n        raise TypeError(\"articles_list must be a list of dicts\")\n\n    # Check if use_palm is valid\n    if use_palm is not None and not isinstance(use_palm, bool):\n        raise TypeError(\"use_palm must be a boolean\")\n\n    # Check if use_palm is True, then tweet and articles_list must be None\n    if use_palm is True and (tweet is not None or articles_list is not None):\n        raise ValueError(\"tweet and articles_list must be None if use_palm is True\")\n\n    # Check if prompt is not provided and use_palm is True\n    if prompt is None and use_palm is True:\n        raise ValueError(\"prompt must be provided if use_palm is True\")\n\n    # Check if tweet and articles_list are both provided\n    if tweet is not None and articles_list is not None:\n        raise ValueError(\"Both tweet and articles_list cannot be provided\")\n\n    # Check if prompt is valid\n    if prompt is not None and not isinstance(prompt, str):\n        raise TypeError(\"prompt must be a string\")\n\n    if articles_list is not None:\n        # Handle the articles list\n        tweet = self.__handle_articles_list(articles_list, title, prompt)\n    elif use_palm:\n        # Generate a tweet using PaLM\n        tweet = self.__generate_with_palm(prompt)\n        if title is not None:\n            tweet = f\"{title}:\\n\\n{tweet}\"\n\n    return self.__tweet(tweet)\n</code></pre>"},{"location":"twitternewsbot/","title":"Twitter News Bot Class","text":""},{"location":"twitternewsbot/#twitternewsbot.twitternewsbot.TwitterNewsBot","title":"<code>TwitterNewsBot</code>","text":"<p>API Object to connect the NewsFinder and Tweeter classes to build a pipeline to automate finding, scraping and tweeting news. Build a .yaml file if needed for Github Actions to run the cron job.</p> Source code in <code>twitternewsbot/twitternewsbot.py</code> <pre><code>class TwitterNewsBot():\n\"\"\"\n    API Object to connect the NewsFinder and Tweeter classes to build a pipeline to automate finding, scraping and tweeting news.\n    Build a .yaml file if needed for Github Actions to run the cron job.\n    \"\"\"\n\n    #####################################\n    # Initialization\n    #####################################\n\n    def __init__(self, news_finder: NewsFinder, tweeter_obj: Tweeter, topic: str, no_of_articles: int = 5):\n\"\"\"Initialize the Bot class\n\n        Parameters\n        ----------\n        news_finder : NewsFinder\n            The NewsFinder object to use to find and scrape news articles\n        tweeter_obj : Tweeter\n            The Tweeter object to use to tweet the news articles\n        topic : str\n            The topic to search for news articles\n        no_of_articles : int, optional\n            The number of articles to find and scrape, by default 5\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If news_finder is not a NewsFinder object\n            If tweeter_obj is not a Tweeter object\n            If topic is not a string\n            If no_of_articles is not an integer\n        \"\"\"\n\n        # Check if news_finder is a NewsFinder object\n        if not isinstance(news_finder, NewsFinder):\n            raise TypeError(\"news_finder must be a NewsFinder object\")\n\n        # Check if tweeter_obj is a Tweeter object\n        if not isinstance(tweeter_obj, Tweeter):\n            raise TypeError(\"tweeter_obj must be a Tweeter object\")\n\n        # Check if topic is a string\n        if not isinstance(topic, str):\n            raise TypeError(\"topic must be a string\")\n\n        # Check if no_of_articles is an integer\n        if not isinstance(no_of_articles, int):\n            raise TypeError(\"no_of_articles must be an integer\")\n\n        # Set the attributes\n        self.news_finder = news_finder\n        self.tweeter_obj = tweeter_obj\n        self.__topic = topic\n        self.__no_of_articles = no_of_articles\n\n    #####################################\n    # Private Methods\n    #####################################\n\n    def __build_pipeline(self, **kwargs) -&gt; dict:\n\"\"\"Private: Build the pipeline to find, scrape and tweet news articles\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Arguments for Tweeter.tweet function excluding articles_list. See Tweeter.tweet for more details on the args. \n\n        Returns\n        -------\n        dict\n            A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet when run\n        \"\"\"\n\n        # Build the pipeline\n        articles = self.news_finder.get_news_articles(topic=self.__topic,number_of_articles=self.__no_of_articles, article_text=True)\n        return self.tweeter_obj.tweet(articles_list=articles, **kwargs)\n\n    def __give_yaml_text(self, cron: str, file: str) -&gt; str:\n\"\"\"Private: Build the .yaml file text for Github Actions to run the cron job\n\n        Parameters\n        ----------\n        cron : str\n            The cron job to run the pipeline.\n            You can get a formatted cron job string from https://crontab.guru/\n        file : str\n            The file to run the pipeline from\n\n        Returns\n        -------\n        str\n            The .yaml file text for Github Actions to run the cron job\n        \"\"\"\n\n        # Build the .yaml file text\n        text = f\"\"\"---\nname: \"Twitter News Bot\"\non:\n  schedule:\n    - cron: '{cron}'\n\njobs:\n  python-job:\n    name: \"Python job\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Setup python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.11.3'\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n      - name: Run python script\n        run: python {file}\"\"\"\n\n        return text\n\n\n\n    ###############################\n    # Public Methods - API Methods\n    ###############################\n\n    @property\n    def topic(self) -&gt; str:\n\"\"\"Returns the topic to search for news articles\n\n        Returns\n        -------\n        str\n            The topic to search for news articles\n        \"\"\"\n        return self.__topic\n\n    @topic.setter\n    def topic(self, topic: str) -&gt; None:\n\"\"\"Sets the topic to search for news articles\n\n        Parameters\n        ----------\n        topic : str\n            The topic to search for news articles\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If topic is not a string\n        \"\"\"\n        # Check if topic is a string\n        if not isinstance(topic, str):\n            raise TypeError(\"topic must be a string\")\n\n        self.__topic = topic\n\n    @property\n    def no_of_articles(self) -&gt; int:\n\"\"\"Returns the number of articles to find and scrape\n\n        Returns\n        -------\n        int\n            The number of articles to find and scrape\n        \"\"\"\n        return self.__no_of_articles\n\n    @no_of_articles.setter\n    def no_of_articles(self, no_of_articles: int) -&gt; None:\n\"\"\"Sets the number of articles to find and scrape\n\n        Parameters\n        ----------\n        no_of_articles : int\n            The number of articles to find and scrape\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If no_of_articles is not an integer\n        \"\"\"\n        # Check if no_of_articles is an integer\n        if not isinstance(no_of_articles, int):\n            raise TypeError(\"no_of_articles must be an integer\")\n\n        self.__no_of_articles = no_of_articles\n\n    def run(self, **kwargs) -&gt; dict:\n\"\"\"\n        Build article list, scrape articles and tweet summarized tweet for the given topic.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Arguments for Tweeter.tweet function excluding articles_list. See Tweeter.tweet for more details on the args.\n\n        Returns\n        -------\n        dict\n            A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet when run\n        \"\"\"\n\n        # Run the pipeline\n        return self.__build_pipeline(**kwargs)\n\n    def build_yaml(self, cron: str, file_name: str) -&gt; None:\n\"\"\"Build a .yaml file for Github Actions to run the cron job\n\n        Parameters\n        ----------\n        cron : str\n            The cron job to run the pipeline.\n            You can get a formatted cron job string from https://crontab.guru/\n        file_name : str\n            The file to run the pipeline from\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If cron is not a string\n        TypeError\n            If file_name is not a string\n        ValueError\n            If cron is not a valid cron job\n        \"\"\"\n\n        # Check if cron is a string\n        if not isinstance(cron, str):\n            raise TypeError(\"cron must be a string\")\n\n        # Check if file is a string\n        if not isinstance(file_name, str):\n            raise TypeError(\"file_name must be a string\")\n\n        # Check if cron is valid cron job\n        if CronValidator.parse(cron) is None:\n            raise ValueError(\"cron must be a valid cron job\")\n\n        # Build the .yml file\n        text = self.__give_yaml_text(cron=cron, file=file_name)\n\n        try:\n            os.mkdir(\".github\")\n        except FileExistsError:\n            pass\n\n        try:\n            os.mkdir(\".github/workflows\")\n        except FileExistsError:\n            pass\n\n        file = open(\".github/workflows/python-app.yml\", \"w\")\n        file.write(text)\n        file.close()\n</code></pre>"},{"location":"twitternewsbot/#twitternewsbot.twitternewsbot.TwitterNewsBot.topic","title":"<code>topic: str</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the topic to search for news articles</p> RETURNS DESCRIPTION <code>str</code> <p>The topic to search for news articles</p>"},{"location":"twitternewsbot/#twitternewsbot.twitternewsbot.TwitterNewsBot.no_of_articles","title":"<code>no_of_articles: int</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the number of articles to find and scrape</p> RETURNS DESCRIPTION <code>int</code> <p>The number of articles to find and scrape</p>"},{"location":"twitternewsbot/#twitternewsbot.twitternewsbot.TwitterNewsBot.run","title":"<code>run(**kwargs)</code>","text":"<p>Build article list, scrape articles and tweet summarized tweet for the given topic.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Arguments for Tweeter.tweet function excluding articles_list. See Tweeter.tweet for more details on the args.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet when run</p> Source code in <code>twitternewsbot/twitternewsbot.py</code> <pre><code>def run(self, **kwargs) -&gt; dict:\n\"\"\"\n    Build article list, scrape articles and tweet summarized tweet for the given topic.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Arguments for Tweeter.tweet function excluding articles_list. See Tweeter.tweet for more details on the args.\n\n    Returns\n    -------\n    dict\n        A dictionary containing the total character count, the number of tweets posted, and the id of the parent tweet when run\n    \"\"\"\n\n    # Run the pipeline\n    return self.__build_pipeline(**kwargs)\n</code></pre>"},{"location":"twitternewsbot/#twitternewsbot.twitternewsbot.TwitterNewsBot.build_yaml","title":"<code>build_yaml(cron, file_name)</code>","text":"<p>Build a .yaml file for Github Actions to run the cron job</p> PARAMETER  DESCRIPTION <code>cron</code> <p>The cron job to run the pipeline. You can get a formatted cron job string from https://crontab.guru/</p> <p> TYPE: <code>str</code> </p> <code>file_name</code> <p>The file to run the pipeline from</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> RAISES DESCRIPTION <code>TypeError</code> <p>If cron is not a string</p> <code>TypeError</code> <p>If file_name is not a string</p> <code>ValueError</code> <p>If cron is not a valid cron job</p> Source code in <code>twitternewsbot/twitternewsbot.py</code> <pre><code>def build_yaml(self, cron: str, file_name: str) -&gt; None:\n\"\"\"Build a .yaml file for Github Actions to run the cron job\n\n    Parameters\n    ----------\n    cron : str\n        The cron job to run the pipeline.\n        You can get a formatted cron job string from https://crontab.guru/\n    file_name : str\n        The file to run the pipeline from\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    TypeError\n        If cron is not a string\n    TypeError\n        If file_name is not a string\n    ValueError\n        If cron is not a valid cron job\n    \"\"\"\n\n    # Check if cron is a string\n    if not isinstance(cron, str):\n        raise TypeError(\"cron must be a string\")\n\n    # Check if file is a string\n    if not isinstance(file_name, str):\n        raise TypeError(\"file_name must be a string\")\n\n    # Check if cron is valid cron job\n    if CronValidator.parse(cron) is None:\n        raise ValueError(\"cron must be a valid cron job\")\n\n    # Build the .yml file\n    text = self.__give_yaml_text(cron=cron, file=file_name)\n\n    try:\n        os.mkdir(\".github\")\n    except FileExistsError:\n        pass\n\n    try:\n        os.mkdir(\".github/workflows\")\n    except FileExistsError:\n        pass\n\n    file = open(\".github/workflows/python-app.yml\", \"w\")\n    file.write(text)\n    file.close()\n</code></pre>"}]}